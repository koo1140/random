<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>AR Pinch Drawing Optimized</title>
<style>
  body { margin:0; overflow:hidden; background:#111; color:#eee; font-family:sans-serif;}
  #startButton { position:absolute; top:20px; left:20px; padding:10px 20px; font-size:16px; cursor:pointer; z-index:10;}
  video { display:none; }
</style>
<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.154.0/build/three.module.js"
  }
}
</script>
</head>
<body>

<button id="startButton">Start AR</button>
<video id="video" autoplay playsinline></video>

<!-- Mediapipe Hands -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>

<script type="module">
import * as THREE from "three";

const video = document.getElementById('video');
const startButton = document.getElementById('startButton');

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 10);
camera.position.z = 0.5;
const renderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

let tips = []; // fingertip points
let fingerLines = []; // line from palm to fingertip

const tipGeom = new THREE.SphereGeometry(0.015,8,8);
const tipMat = new THREE.MeshNormalMaterial();
const lineMat = new THREE.LineBasicMaterial({color:0x00ff00});

let drawing = false;
let currentLine = null;
let drawPoints = [];
const drawMaterial = new THREE.LineBasicMaterial({ color: 0xff0000, linewidth: 3 });

function distance(a, b){
    return a.clone().sub(b).length();
}

let hands;

startButton.onclick = async ()=>{
  startButton.style.display='none';
  try{
    const stream = await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment'}});
    video.srcObject = stream;
    await video.play();

    hands = new Hands({locateFile: (file)=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({maxNumHands:2, modelComplexity:1, minDetectionConfidence:0.5, minTrackingConfidence:0.5});
    hands.onResults(onHands);

    requestAnimationFrame(handLoop);
  }catch(e){ console.error(e); }
};

async function handLoop(){
  try{
    if(hands && video.readyState >= 2){
      await hands.send({image: video});
    }
  }catch(e){ console.error('Hand send error: '+e); }
  requestAnimationFrame(handLoop);
}

function onHands(results){
  // clear previous
  tips.forEach(s=>scene.remove(s)); tips=[];
  fingerLines.forEach(l=>scene.remove(l)); fingerLines=[];

  if(!results.multiHandLandmarks) return;

  results.multiHandLandmarks.forEach(landmarks=>{
    const palm = new THREE.Vector3((landmarks[0].x-0.5)*0.4,(0.5-landmarks[0].y)*0.4,-landmarks[0].z*0.4);
    const tipIndices = [4,8,12,16,20]; // thumb,index,middle,ring,pinky

    tipIndices.forEach(i=>{
      const lm = landmarks[i];
      const pos = new THREE.Vector3((lm.x-0.5)*0.4,(0.5-lm.y)*0.4,-lm.z*0.4);
      const sphere = new THREE.Mesh(tipGeom, tipMat);
      sphere.position.copy(pos);
      scene.add(sphere); tips.push(sphere);

      const line = new THREE.Line(new THREE.BufferGeometry().setFromPoints([palm,pos]), lineMat);
      scene.add(line); fingerLines.push(line);
    });

    // Pinch (thumb + index)
    const thumb = landmarks[4];
    const index = landmarks[8];
    const thumbPos = new THREE.Vector3((thumb.x-0.5)*0.4,(0.5-thumb.y)*0.4,-thumb.z*0.4);
    const indexPos = new THREE.Vector3((index.x-0.5)*0.4,(0.5-index.y)*0.4,-index.z*0.4);

    if(distance(thumbPos,indexPos)<0.03){
      if(!drawing){
        drawing=true;
        drawPoints=[];
        const geom = new THREE.BufferGeometry();
        currentLine = new THREE.Line(geom, drawMaterial);
        scene.add(currentLine);
      }
      const mid = thumbPos.clone().add(indexPos).multiplyScalar(0.5);
      drawPoints.push(mid);
      currentLine.geometry.setFromPoints(drawPoints);
    } else {
      drawing=false;
      currentLine=null;
      drawPoints=[];
    }
  });
}

renderer.setAnimationLoop(()=>{
  renderer.render(scene,camera);
});
</script>

</body>
</html>
