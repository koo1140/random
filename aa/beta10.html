<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Photosphere Capture</title>
<style>
  body, html {margin:0; padding:0; overflow:hidden; font-family:sans-serif; background:#000; color:#fff;}
  #ui {position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none;}
  #target {position:absolute; width:40px; height:40px; border:2px solid #0f0; border-radius:50%; transform:translate(-50%,-50%);}
  #guidance {position:absolute; bottom:10px; left:50%; transform:translateX(-50%); font-size:18px; color:#0f0;}
  #buttons {position:absolute; top:10px; left:50%; transform:translateX(-50%); pointer-events:auto;}
  #buttons button {margin:0 5px; padding:10px; font-size:16px;}
  canvas {display:none;}
</style>
</head>
<body>

<video id="camera" autoplay playsinline style="width:100%; height:100%; object-fit:cover;"></video>
<div id="ui">
  <div id="target"></div>
  <div id="guidance"></div>
  <div id="buttons">
    <button id="capture">Capture</button>
    <button id="process">Process & Save Sphere</button>
    <button id="view">View Saved Spheres</button>
  </div>
</div>
<canvas id="canvas"></canvas>

<script>
const video = document.getElementById('camera');
const target = document.getElementById('target');
const guidance = document.getElementById('guidance');
const captureBtn = document.getElementById('capture');
const processBtn = document.getElementById('process');
const viewBtn = document.getElementById('view');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let db;
let captures = [];
let currentPoint = 0;
const points = [];

// Generate 3D points (yaw/pitch) for full 360 coverage (every 45° yaw and pitch 45°/-45°/0)
for (let pitch of [-45,0,45]) {
  for (let yaw = 0; yaw < 360; yaw += 45) {
    points.push({yaw, pitch});
  }
}

let orientation = {alpha:0, beta:0, gamma:0};

async function initCamera() {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment'}});
    video.srcObject = stream;
  } catch(e) {
    alert('Camera init failed: '+e);
  }
}

function saveCapture(imageData) {
  captures.push({imageData, point:points[currentPoint]});
}

function rotateToScreen(yaw,pitch){
  // Map yaw/pitch to screen position
  const centerX = window.innerWidth/2;
  const centerY = window.innerHeight/2;
  const maxOffset = Math.min(centerX, centerY)*0.8;
  const dx = Math.sin((yaw-orientation.alpha)*Math.PI/180)*maxOffset;
  const dy = -Math.sin((pitch-orientation.beta)*Math.PI/180)*maxOffset;
  return {x:centerX+dx, y:centerY+dy};
}

function updateTarget() {
  if(currentPoint>=points.length){
    target.style.display='none';
    guidance.textContent='All points captured';
    return;
  }
  const p = points[currentPoint];
  const pos = rotateToScreen(p.yaw,p.pitch);
  target.style.left = pos.x+'px';
  target.style.top = pos.y+'px';

  const distX = pos.x - window.innerWidth/2;
  const distY = pos.y - window.innerHeight/2;
  const tol = 40;
  let hint = '';
  if(Math.abs(distY)>tol) hint += distY>0?'Move Down ':'Move Up ';
  if(Math.abs(distX)>tol) hint += distX>0?'Move Right ':'Move Left ';
  if(hint==='') hint='Aligned';
  guidance.textContent = hint;
}

window.addEventListener('deviceorientation', e=>{
  orientation.alpha = e.alpha||0;
  orientation.beta = e.beta||0;
  orientation.gamma = e.gamma||0;
  updateTarget();
});

captureBtn.addEventListener('click', ()=>{
  if(currentPoint>=points.length) return;
  canvas.width = video.videoWidth;
  canvas.height = video.videoHeight;
  ctx.drawImage(video,0,0,canvas.width,canvas.height);
  const imgData = canvas.toDataURL('image/jpeg',0.8);
  saveCapture(imgData);
  currentPoint++;
  updateTarget();
});

async function initDB() {
  db = await new Promise((resolve, reject)=>{
    const r = indexedDB.open('photosphereDB',1);
    r.onupgradeneeded = e=>{
      const db = e.target.result;
      db.createObjectStore('spheres',{autoIncrement:true});
    };
    r.onsuccess = e=>resolve(e.target.result);
    r.onerror = e=>reject(e);
  });
}

processBtn.addEventListener('click', async ()=>{
  if(captures.length===0){alert('No captures'); return;}
  guidance.textContent='Processing...';
  // simple pixel-level blending stitching
  const w = 1024, h=512;
  const outCanvas = document.createElement('canvas');
  outCanvas.width=w; outCanvas.height=h;
  const outCtx = outCanvas.getContext('2d');

  // naive: draw each image scaled
  for(let c of captures){
    const img = new Image();
    img.src=c.imageData;
    await new Promise(r=>img.onload=r);
    outCtx.globalAlpha=1/captures.length;
    outCtx.drawImage(img,0,0,w,h);
  }
  // save to IndexedDB
  const tx = db.transaction('spheres','readwrite');
  tx.objectStore('spheres').add(outCanvas.toDataURL('image/jpeg',0.9));
  tx.oncomplete = ()=>{guidance.textContent='Sphere saved!'; captures=[]; currentPoint=0; updateTarget();};
});

viewBtn.addEventListener('click', async ()=>{
  const tx = db.transaction('spheres','readonly');
  const store = tx.objectStore('spheres');
  const all = [];
  store.openCursor().onsuccess = e=>{
    const cursor = e.target.result;
    if(cursor){
      all.push(cursor.value);
      cursor.continue();
    } else {
      if(all.length===0){alert('No saved spheres'); return;}
      // open viewer
      const viewer = window.open('','Sphere Viewer','width=400,height=300');
      viewer.document.write('<body style="margin:0;background:black;"><canvas id="v" style="width:100%;height:100%;"></canvas></body>');
      const vCanvas = viewer.document.getElementById('v');
      const vCtx = vCanvas.getContext('2d');
      let alpha=0, beta=0;
      const img = new Image();
      img.src=all[all.length-1];
      img.onload = ()=>{
        vCanvas.width = img.width;
        vCanvas.height = img.height;
        function draw(){ 
          const xOffset = ((alpha%360)/360)*img.width;
          vCtx.clearRect(0,0,vCanvas.width,vCanvas.height);
          vCtx.drawImage(img,xOffset,0,vCanvas.width,vCanvas.height,0,0,vCanvas.width,vCanvas.height);
          requestAnimationFrame(draw);
        }
        draw();
      };
      viewer.addEventListener('deviceorientation',e=>{
        alpha = e.alpha||0;
        beta = e.beta||0;
      });
    }
  };
});

initCamera();
initDB();
updateTarget();
</script>
</body>
</html>
